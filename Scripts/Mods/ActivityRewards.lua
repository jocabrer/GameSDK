--
----------------------------------------------------------------------------------------------------------------------
-- 									                ACTIVITY REWARDS
----------------------------------------------------------------------------------------------------------------------
--
--          Activity Rewards is a customizable wage system created for rewarding players at a defined frequency.
--           Admins can customize the mod with a configuration file to adjust several key points of this system.
--
--                         For more information on the mod, please check the Workshop page :
--                         https://steamcommunity.com/sharedfiles/filedetails/?id=2261444032
--
--      If you need any help on this system : please contact @PitiViers in MisModding Discord : discord.gg/ttdzgzp
--             Special thanks to Theros for creating and kindly sharing the timer Thread and mSpawnTools.
--
--                                - Inspired by the Wages system of Arma 3 ExileMod -
--
--                                              Have fun !   -PitiViers.
--
---------------------------------------------------------------------------------------------------------------------
--
--  LAST UPDATE --
--
-- . Added several new variables for admins to personalize the Text Feedbacks.
-- . Added a [Chat Command] for players to control infos about their next rewards.
-- . The Chat Command can be enabled or disabled from the Config file.
-- . Added [Random Rewards]. Players will be able to earn various rewards randomly.
-- . Admins can set a pool of Rewards, and their min/max amounts with a provided Table in Config.
-- . The script will choose a different Reward randomly for each players online.
-- . Added a small note in Config to explain what to do when playing on Custom Maps.
--
--
-- ─── CONFIG FUNCTIONS ─────────────────────────────────────────────────────────────────────────────────────────────
--
-- (!) NOTE
-- (!) The configuration is handled by a lua file created at game server root the first time the mod is launched on a server.
-- (!) Edit the configuration to customize the mod @ ActivityRewards_Config.lua
-- (!) DO NOT EDIT THIS FILE just to change the configuration.
--

-- Default Configuration
local activityRewardsConf = {

	-- Reward Params ------------------------------------------------------------------------------------------------------------------------------------------------------
	Timer = 15,                                     --- How often a player should be rewarded - in minutes.
	RewardItem = 'AmcoinLedger',                    --- Which item to give for reward - (((Keep the quotes !)))
	RewardItemCount = 5,                            --- Number of items to give for each reward. Items will autostack on a new empty slot.
	AllowSafeZoneRewards = 0,                       --- Enable (1) or disable (0) rewards for players that are around Safe Zones.
	RandomRewards = 0,                              --- Enable (1) or disable (0) Random Rewards. See provided Spawn Table below for more infos.

-- Base Params --------------------------------------------------------------------------------------------------------------------------------------------------------
	BaseCheck = 1,                                  --- Enable (1) or disable (0) Base Check. When enabled, a player can't get a reward around his base.
	BaseCheckDistance = 60,                         --- Minimum distance a player should be from his PlotSign to earn rewards. That should at least match PlotSign radius.
	AllowNoBaseRewards = 1,                         --- Enable (1) or disable (0) rewards for players without a base.

-- Text Feedbacks -----------------------------------------------------------------------------------------------------------------------------------------------------
	Title = 'Activity Rewards',                     --- Title to display as a prefix of the Chat Text Feedback - (((Keep the quotes !)))
	Notification = 'New Reward Delivered !',        --- Notification to display on top-screen when a Reward is delivered. Leave empty to disable - (((Keep the quotes !)))
	NotifBase = 'No Reward around your Base !',     --- Notification to display on top-screen when Base Reward is denied. Leave empty to disable - (((Keep the quotes !)))
	NotifSafeZone = 'No Reward around Safe Zone !', --- Notification to display on top-screen when Safe Zone Reward is denied. Leave empty to disable - (((Keep the quotes !)))

--	Chat Commands -----------------------------------------------------------------------------------------------------------------------------------------------------
	AllowChatCommand = 1,                           --- Enable (1) or disable (0) the (!reward) ChatCommand for players -- holds various infos about the next reward.

-- Other Params	-------------------------------------------------------------------------------------------------------------------------------------------------------
	CurrentMap = 'Orca',                            --- Change this to 'Canyon' if your server is on Canyonlands. 'Orca' is default. - (((Keep the quotes !)))
													--- NOTE : Activity Rewards does not support Custom Maps. Just leave on 'Orca' and disable "AllowSafeZoneRewards".


--------------------------------
-- Random Rewards Spawn Table
--------------------------------

-- This lua table is at your disposal to setup your Random Rewards
-- You can add as much items as you want, but you have to follow the exact same method :
--
-- ["Item_Name"] = { min = X, max = Y },
--
-- Be sure to always keep the brackets, the quotes and the ending comma
-- Activity Rewards will choose a random item+value and give them to the Players
-- Each players will earn a different item and/or value.
--
-- Existing Items are here for the example, they can freely be modified.

SpawnTable = {

	["AppleFresh"] = { min = 1, max = 3 },
	["WoodPile"]   = { min = 5, max = 10 },
	["StickPile"]  = { min = 5, max = 20 },
-- follow up with as many items as you want....

	}
}

-- Text to write if ActivityRewards_Config.lua is missing
local configuration = [[
-------------------------------------------------------------------------
               -- ACTIVITY REWARDS CONFIGURATION --
-------------------------------------------------------------------------

-- Need help ? Please contact @PitiViers in MisModding Discord : discord.gg/ttdzgzp

local ActivityRewardsConfiguration = {

	-- Reward Params ------------------------------------------------------------------------------------------------------------------------------------------------------
	Timer = 15,                                     --- How often a player should be rewarded - in minutes.
	RewardItem = 'AmcoinLedger',                    --- Which item to give for reward - (((Keep the quotes !)))
	RewardItemCount = 5,                            --- Number of items to give for each reward. Items will autostack on a new empty slot.
	AllowSafeZoneRewards = 0,                       --- Enable (1) or disable (0) rewards for players that are around Safe Zones.
	RandomRewards = 0,                              --- Enable (1) or disable (0) Random Rewards. See provided Spawn Table below for more infos.

-- Base Params --------------------------------------------------------------------------------------------------------------------------------------------------------
	BaseCheck = 1,                                  --- Enable (1) or disable (0) Base Check. When enabled, a player can't get a reward around his base.
	BaseCheckDistance = 60,                         --- Minimum distance a player should be from his PlotSign to earn rewards. That should at least match PlotSign radius.
	AllowNoBaseRewards = 1,                         --- Enable (1) or disable (0) rewards for players without a base.

-- Text Feedbacks -----------------------------------------------------------------------------------------------------------------------------------------------------
	Title = 'Activity Rewards',                     --- Title to display as a prefix of the Chat Text Feedback - (((Keep the quotes !)))
	Notification = 'New Reward Delivered !',        --- Notification to display on top-screen when a Reward is delivered. Leave empty to disable - (((Keep the quotes !)))
	NotifBase = 'No Reward around your Base !',     --- Notification to display on top-screen when Base Reward is denied. Leave empty to disable - (((Keep the quotes !)))
	NotifSafeZone = 'No Reward around Safe Zone !', --- Notification to display on top-screen when Safe Zone Reward is denied. Leave empty to disable - (((Keep the quotes !)))

--	Chat Commands -----------------------------------------------------------------------------------------------------------------------------------------------------
	AllowChatCommand = 1,                           --- Enable (1) or disable (0) the (!reward) ChatCommand for players -- holds various infos about the next reward.

-- Other Params	-------------------------------------------------------------------------------------------------------------------------------------------------------
	CurrentMap = 'Orca',                            --- Change this to 'Canyon' if your server is on Canyonlands. 'Orca' is default. - (((Keep the quotes !)))
													--- NOTE : Activity Rewards does not support Custom Maps. Just leave on 'Orca' and disable "AllowSafeZoneRewards".


--------------------------------
-- Random Rewards Spawn Table
--------------------------------

-- This lua table is at your disposal to setup your Random Rewards
-- You can add as much items as you want, but you have to follow the exact same method :
--
-- ["Item_Name"] = { min = X, max = Y },
--
-- Be sure to always keep the brackets, the quotes and the ending comma
-- Activity Rewards will choose a random item+value and give them to the Players
-- Each players will earn a different item and/or value.
--
-- Existing Items are here for the example, they can freely be modified.

SpawnTable = {

	["AppleFresh"] = { min = 1, max = 3 },
	["WoodPile"]   = { min = 5, max = 10 },
	["StickPile"]  = { min = 5, max = 20 },
-- follow up with as many items as you want....

	}
}

return ActivityRewardsConfiguration;                    --- Do not touch this !
	]];

--- CONFIG FILE MANAGEMENT ---------------------------------------------------------------------------------------

-- Writing function on ActivityRewards_Config.lua
local function WriteConfig(filename)
	os.execute("mkdir Mods_Config")
	file = io.open ('Mods_Config/ActivityRewards_Config.lua', "w");
	file:write(configuration);
	file:close();
end

-- Main function -- Reads ActivityRewards_Config.lua and apply the configuration
local function SetConfig(filename)
	local file = io.open ("Mods_Config/ActivityRewards_Config.lua");
	if file == nil then
		WriteConfig(filename);
		LogWarning('Activity Rewards : Configuration file has been created')
		return;
	end
	file:close();
	package.path = "./Mods_Config/"..filename..";"..package.path;
	local ActivityRewardsConfiguration = require(filename);
	for a, b in pairs(ActivityRewardsConfiguration) do
		activityRewardsConf[a] = b;
	end
	LogWarning('Activity Rewards : Configuration has been fetch from ActivityRewards_Config.lua')
end

	SetConfig("ActivityRewards_Config.lua"); -- Call Immediately

--
-- ───────────────────────────────────────────────────────────────────────────────────────── CONFIG END ─────────
-----------------------------------------------------------------------------------------------------------------
-- ─── MAIN FUNCTIONS ───────────────────────────────────────────────────────────────────────────────────────────
--
--
--  Tools -------------------------------------------------------------------------------------------------------

local function getTime() return os.clock() * 1000 end -- Returns the processed time in milliseconds

PlayerHasBase = {} -- Empty table used to validate if a player has a base on the server

-- SAFE ZONE COORDS -- reference to determine Exclusion zones for Rewards ---------------------------------------

local SZOrca = {
	MinX = 4850.0,
	MaxX = 5020.0,
	MinY = 4600.0,
	MaxY = 4770.0,
	}

local SZCanyon = {
	MinX = 1620.0,
	MaxX = 1830.0,
	MinY = 2070.0,
	MaxY = 2275.0,
	}


-- RANDOM REWARDS TOOL -------------------------------------------------------------------------------------------

local function RndTable(tbl)
    local keys = {}
    for key, _ in pairs(tbl) do
        table.insert(keys, key)
    end
    local max = #keys
    local number = math.random(1, max)
    local selectedKey = keys[number]
    return selectedKey, tbl[selectedKey]
end

-- Functions ----------------------------------------------------------------------------------------------------

-- Main Function

local function ActivityReward(self)
-- Fetch the current Player List
    local OnlinePlayers = (CryAction.GetPlayerList() or {})
-- Check the player count
    local playerCount = table.getn(OnlinePlayers)
    LogWarning('ActivityRewards: We have %s Players.', tostring(playerCount))
		if (playerCount >= 1) then
			for idx, player in pairs(OnlinePlayers) do -- start loop through every online player
				if player and player.player then -- ensure we only act on valid players
					local playerId = player.id
					local steamId = player.player:GetSteam64Id();
						LogWarning(
						'ActivityRewards Processing Player[%s]: %s[%s]', tostring(idx), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id()
						)

-- First, we check if AllowSafeZoneRewards is enabled, and where is the player currently.

					if activityRewardsConf.AllowSafeZoneRewards == 0 then

					--LogWarning('ActivityRewards: AllowSafeZoneRewards is disabled')

						if activityRewardsConf.CurrentMap == 'Orca' then

							--LogWarning('ActivityRewards: CurrentMap is Orca')

					    local playerPos = player:GetWorldPos()

							if playerPos.x > SZOrca.MinX and playerPos.x < SZOrca.MaxX and playerPos.y > SZOrca.MinY and playerPos.y < SZOrca.MaxY then

	-- Player is inside the 4 sides of the Safe Zone area, Reward denied

							local err_msg = string.format(
											'%s : You do not earn rewards if you are in Safe Zone. Next reward in %s minutes.',
												tostring(activityRewardsConf.Title), tostring(activityRewardsConf.Timer)
												)
							local notif_SF = string.format(
								'%s', tostring(activityRewardsConf.NotifSafeZone)
									)
							g_gameRules.game:SendTextMessage(0, playerId, notif_SF)
							g_gameRules.game:SendTextMessage(4, playerId, err_msg)

							LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to the Safe Zone, aborting.', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())

							else

	-- Player is outside of the Safe Zone, proceeding

-- If BaseCheck is disabled, we can give Rewards to all active players

					if activityRewardsConf.BaseCheck == 0 then

						local itemCount = activityRewardsConf.RewardItemCount
						local rewardItem = activityRewardsConf.RewardItem
						if activityRewardsConf.RandomRewards == 1 then
							local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
							local Amount = math.random(Count.min, Count.max)

							mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

							g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
						local msg_txt = string.format(
                                    '%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
                                    tostring(RndItem), tostring(activityRewardsConf.Timer)
									)
						g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
						g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message

						else
							mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

						LogWarning(
						'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id()
						)

						g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
						local msg_txt = string.format(
                                    '%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
                                    tostring(rewardItem), tostring(activityRewardsConf.Timer)
									)
						g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
						g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message

					end

-- If BaseCheck is enabled, we start the Check job on all bases

					elseif activityRewardsConf.BaseCheck == 1 then
						--LogWarning('ActivityRewards: BaseCheck is enabled')

						PlayerHasBase[playerId] = false -- at the start of BaseCheck, we ensure each Player validates the checking process

						local bases = BaseBuildingSystem.GetPlotSigns(); -- fetching Base list
						LogWarning('ActivityRewards: Checking base for player[%s]: %s[%s]', tostring(idx), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id())

							for i,b in pairs(bases) do
								if b.plotsign:GetOwnerSteam64Id() == steamId then -- we check if player have a base on the server

									PlayerHasBase[playerId] = true -- We ensure each Player has a base on the server by attributing the empty table
										LogWarning('ActivityRewards : Player [%s]: %s[%s] has a base on the server.', tostring(idx), player:GetName(),
											player.player:GetSteam64Id(), player.player:GetSteam64Id())

									local Ppos = player:GetWorldPos()
									local Bpos = b:GetWorldPos()
									local MinDist = activityRewardsConf.BaseCheckDistance

									LogWarning('ActivityRewards: Start checking distance between base and Player [%s]: %s[%s]', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())

-- BaseCheck : We check if player is far enough from his base to earn a Reward

-- First on X axis :

									if (Ppos.x - Bpos.x) > MinDist or (Ppos.x - Bpos.x) < -MinDist then

-- If BaseCheck on X axis is OK, we can give a Reward

										local itemCount = activityRewardsConf.RewardItemCount
										local rewardItem = activityRewardsConf.RewardItem

											LogWarning('ActivityRewards: player[%s]: %s[%s] is distant enough on X', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())
												if activityRewardsConf.RandomRewards == 1 then
													local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
													local Amount = math.random(Count.min, Count.max)

													mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

													g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
															tostring(RndItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
												g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message

												else
													mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

												LogWarning(
												'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id()
												)

												g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
															tostring(rewardItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
												g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message
											end

-- If BaseCheck is not OK on X, we try with Y

									elseif (Ppos.y - Bpos.y) > MinDist or (Ppos.y - Bpos.y) < -MinDist then

-- BaseCheck on Y is OK, we can give a reward

										local itemCount = activityRewardsConf.RewardItemCount
										local rewardItem = activityRewardsConf.RewardItem

											LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to X, but OK for Y', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())
												if activityRewardsConf.RandomRewards == 1 then
													local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
													local Amount = math.random(Count.min, Count.max)

													mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

													g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
															tostring(RndItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
												g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message

												else
													mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

												LogWarning(
												'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id()
												)

												g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
															tostring(rewardItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
											end

-- If BaseCheck is not OK (under minimal distance on both X and Y from the PlotSign) then no reward, and sending warning message.

									else

										local err_msg = string.format(
											'%s : You do not earn rewards if you are too close to your Base. Next reward in %s minutes.', tostring(activityRewardsConf.Title), tostring(activityRewardsConf.Timer)
												)
										local notif_base = string.format(
											'%s', tostring(activityRewardsConf.NotifBase))

										g_gameRules.game:SendTextMessage(0, playerId, notif_base)
										g_gameRules.game:SendTextMessage(4, playerId, err_msg)

											LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to his plot sign', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())


									end --DistanceCheck end
								end
							end -- BaseCheck end

-- We also give Rewards to players without base - but only if AllowNoBaseRewards is enabled, using the empty PlayerHasBase table

						if not PlayerHasBase[playerId] then

							if activityRewardsConf.AllowNoBaseRewards == 1 then
							--LogWarning('ActivityRewards: AllowNoBaseRewards is enabled')

								local itemCount = activityRewardsConf.RewardItemCount
								local rewardItem = activityRewardsConf.RewardItem

									LogWarning('ActivityRewards: Player[%s]: %s[%s] does not have a base on the server', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())
										if activityRewardsConf.RandomRewards == 1 then
											local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
											local Amount = math.random(Count.min, Count.max)

											mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

											g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
										local msg_txt = string.format(
													'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
													tostring(RndItem), tostring(activityRewardsConf.Timer)
													)
										g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
										g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message

										else
											mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

										LogWarning(
										'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id()
										)

										g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
										local msg_txt = string.format(
													'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
													tostring(rewardItem), tostring(activityRewardsConf.Timer)
													)
										g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
										g_gameRules.game:SendTextMessage(0, playerId, msg_txt) -- send chat message
									end

							else
								--LogWarning('ActivityRewards: AllowNoBaseRewards is disabled')
							end
						end
					else
					LogWarning('ActivityRewards: WARNING Wrong BaseCheck configuration ! Choose 0 to disable or 1 to enable !')
				end -- Reward end
			end

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Reward is done for Orca, but now we have to act the same way for Canyonland
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			elseif activityRewardsConf.CurrentMap == 'Canyon' then

				--LogWarning('ActivityRewards: CurrentMap is Canyon')

				local playerPos = player:GetWorldPos()

							if playerPos.x > SZCanyon.MinX and playerPos.x < SZCanyon.MaxX and playerPos.y > SZCanyon.MinY and playerPos.y < SZCanyon.MaxY then

		-- Player is inside the 4 sides of the Safe Zone area, Reward denied

							local err_msg = string.format(
											'%s : You do not earn rewards if you are in Safe Zone. Next reward in %s minutes.', tostring(activityRewardsConf.Title), tostring(activityRewardsConf.Timer)
												)
												local notif_SF = string.format(
													'%s', tostring(activityRewardsConf.NotifSafeZone)
														)
												g_gameRules.game:SendTextMessage(0, playerId, notif_SF)
							g_gameRules.game:SendTextMessage(4, playerId, err_msg)

							LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to the Safe Zone, aborting.', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())

							else

		-- Player is outside of the Safe Zone, proceeding

-- If BaseCheck is disabled, we can give Rewards to all active players

					if activityRewardsConf.BaseCheck == 0 then

						local itemCount = activityRewardsConf.RewardItemCount
						local rewardItem = activityRewardsConf.RewardItem
						if activityRewardsConf.RandomRewards == 1 then
							local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
							local Amount = math.random(Count.min, Count.max)

							mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

							g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
						local msg_txt = string.format(
                                    '%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
                                    tostring(RndItem), tostring(activityRewardsConf.Timer)
									)
						g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

						else
							mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

						LogWarning(
						'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id()
						)

						g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
						local msg_txt = string.format(
                                    '%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
                                    tostring(rewardItem), tostring(activityRewardsConf.Timer)
									)
						g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
					end


-- If BaseCheck is enabled, we start the Check job on all bases

					elseif activityRewardsConf.BaseCheck == 1 then
						--LogWarning('ActivityRewards: BaseCheck is enabled')

						PlayerHasBase[playerId] = false -- at the start of BaseCheck, we ensure each Player validates the checking process

						local bases = BaseBuildingSystem.GetPlotSigns(); -- fetching Base list
						LogWarning('ActivityRewards: Checking base for player[%s]: %s[%s]', tostring(idx), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id())

							for i,b in pairs(bases) do
								if b.plotsign:GetOwnerSteam64Id() == steamId then -- we check if player have a base on the server

									PlayerHasBase[playerId] = true -- We ensure each Player has a base on the server by attributing the empty table
										LogWarning('ActivityRewards : Player [%s]: %s[%s] has a base on the server.', tostring(idx), player:GetName(),
											player.player:GetSteam64Id(), player.player:GetSteam64Id())

									local Ppos = player:GetWorldPos()
									local Bpos = b:GetWorldPos()
									local MinDist = activityRewardsConf.BaseCheckDistance

									LogWarning('ActivityRewards: Start checking distance between base and Player [%s]: %s[%s]', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())

-- BaseCheck : We check if player is far enough from his base to earn a Reward

-- First on X axis :

									if (Ppos.x - Bpos.x) > MinDist or (Ppos.x - Bpos.x) < -MinDist then

-- If BaseCheck on X axis is OK, we can give a Reward

										local itemCount = activityRewardsConf.RewardItemCount
										local rewardItem = activityRewardsConf.RewardItem

											LogWarning('ActivityRewards: player[%s]: %s[%s] is distant enough on X', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())
												if activityRewardsConf.RandomRewards == 1 then
													local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
													local Amount = math.random(Count.min, Count.max)

													mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

													g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
															tostring(RndItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

												else
													mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

												LogWarning(
												'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id()
												)

												g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
															tostring(rewardItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
											end

-- If BaseCheck is not OK on X, we try with Y

									elseif (Ppos.y - Bpos.y) > MinDist or (Ppos.y - Bpos.y) < -MinDist then

-- BaseCheck on Y is OK, we can give a reward

										local itemCount = activityRewardsConf.RewardItemCount
										local rewardItem = activityRewardsConf.RewardItem

											LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to X, but OK for Y', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())
												if activityRewardsConf.RandomRewards == 1 then
													local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
													local Amount = math.random(Count.min, Count.max)

													mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

													g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
															tostring(RndItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

												else
													mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

												LogWarning(
												'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id()
												)

												g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
															tostring(rewardItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
											end

-- If BaseCheck is not OK (under minimal distance on both X and Y from the PlotSign) then no reward, and sending warning message.

									else

										local err_msg = string.format(
											'%s : You do not earn rewards if you are too close to your Base. Next reward in %s minutes.', tostring(activityRewardsConf.Title), tostring(activityRewardsConf.Timer)
												)
										local notif_base = string.format(
											'%s', tostring(activityRewardsConf.NotifBase)
												)

												g_gameRules.game:SendTextMessage(0, playerId, notif_base)
												g_gameRules.game:SendTextMessage(4, playerId, err_msg)

											LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to his plot sign', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())


									end --DistanceCheck end
								end
							end -- BaseCheck end

-- We also give Rewards to players without base - but only if AllowNoBaseRewards is enabled, using the empty PlayerHasBase table

						if not PlayerHasBase[playerId] then

							if activityRewardsConf.AllowNoBaseRewards == 1 then
							--LogWarning('ActivityRewards: AllowNoBaseRewards is enabled')

								local itemCount = activityRewardsConf.RewardItemCount
								local rewardItem = activityRewardsConf.RewardItem

									LogWarning('ActivityRewards: Player[%s]: %s[%s] does not have a base on the server', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())
										if activityRewardsConf.RandomRewards == 1 then
											local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
											local Amount = math.random(Count.min, Count.max)

											mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

											g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
										local msg_txt = string.format(
													'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
													tostring(RndItem), tostring(activityRewardsConf.Timer)
													)
										g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

										else
											mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

										LogWarning(
										'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id()
										)

										g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
										local msg_txt = string.format(
													'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
													tostring(rewardItem), tostring(activityRewardsConf.Timer)
													)
										g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
									end

							else
								--LogWarning('ActivityRewards: AllowNoBaseRewards is disabled')
							end
						end
					else
					LogWarning('ActivityRewards: WARNING Wrong BaseCheck configuration ! Choose 0 to disable or 1 to enable !')
				end -- Reward end
			end

		else

			LogWarning('ActivityRewards: WARNING Wrong CurrentMap configuration !')

			end

--------------------------------------------------------------------------------------------------------------------------
		else 	-- AllowSafeZoneRewards is disabled, players can earn rewards in Safe Zones, proceeding without SZ Check
--------------------------------------------------------------------------------------------------------------------------

			--LogWarning('ActivityRewards: AllowSafeZoneRewards is enabled')

				if activityRewardsConf.BaseCheck == 0 then

						local itemCount = activityRewardsConf.RewardItemCount
						local rewardItem = activityRewardsConf.RewardItem

						--LogWarning('ActivityRewards: BaseCheck is disabled')
						if activityRewardsConf.RandomRewards == 1 then
							local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
							local Amount = math.random(Count.min, Count.max)

							mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

							g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
						local msg_txt = string.format(
                                    '%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
                                    tostring(RndItem), tostring(activityRewardsConf.Timer)
									)
						g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

						else
							mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

						LogWarning(
						'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id()
						)

						g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
						local msg_txt = string.format(
                                    '%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
                                    tostring(rewardItem), tostring(activityRewardsConf.Timer)
									)
						g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
					end


-- If BaseCheck is enabled, we start the Check job on all bases

					elseif activityRewardsConf.BaseCheck == 1 then
						--LogWarning('ActivityRewards: BaseCheck is enabled')

						PlayerHasBase[playerId] = false -- at the start of BaseCheck, we ensure each Player validates the checking process

						local bases = BaseBuildingSystem.GetPlotSigns(); -- fetching Base list
						LogWarning('ActivityRewards: Checking base for player[%s]: %s[%s]', tostring(idx), player:GetName(),
						player.player:GetSteam64Id(), player.player:GetSteam64Id())

							for i,b in pairs(bases) do
								if b.plotsign:GetOwnerSteam64Id() == steamId then -- we check if player have a base on the server

									PlayerHasBase[playerId] = true -- We ensure each Player has a base on the server by attributing the empty table
										LogWarning('ActivityRewards : Player [%s]: %s[%s] has a base on the server.', tostring(idx), player:GetName(),
											player.player:GetSteam64Id(), player.player:GetSteam64Id())

									local Ppos = player:GetWorldPos()
									local Bpos = b:GetWorldPos()
									local MinDist = activityRewardsConf.BaseCheckDistance

									LogWarning('ActivityRewards: Start checking distance between base and Player [%s]: %s[%s]', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())

-- BaseCheck : We check if player is far enough from his base to earn a Reward

-- First on X axis :

									if (Ppos.x - Bpos.x) > MinDist or (Ppos.x - Bpos.x) < -MinDist then

-- If BaseCheck on X axis is OK, we can give a Reward

										local itemCount = activityRewardsConf.RewardItemCount
										local rewardItem = activityRewardsConf.RewardItem

											LogWarning('ActivityRewards: player[%s]: %s[%s] is distant enough on X', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())
												if activityRewardsConf.RandomRewards == 1 then
													local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
													local Amount = math.random(Count.min, Count.max)

													mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

													g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
															tostring(RndItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

												else
													mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

												LogWarning(
												'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id()
												)

												g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
															tostring(rewardItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
											end

-- If BaseCheck is not OK on X, we try with Y

									elseif (Ppos.y - Bpos.y) > MinDist or (Ppos.y - Bpos.y) < -MinDist then

-- BaseCheck on Y is OK, we can give a reward

										local itemCount = activityRewardsConf.RewardItemCount
										local rewardItem = activityRewardsConf.RewardItem

											LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to X, but OK for Y', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())
												if activityRewardsConf.RandomRewards == 1 then
													local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
													local Amount = math.random(Count.min, Count.max)

													mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

													g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
															tostring(RndItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

												else
													mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

												LogWarning(
												'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id()
												)

												g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
												local msg_txt = string.format(
															'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
															tostring(rewardItem), tostring(activityRewardsConf.Timer)
															)
												g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
											end

-- If BaseCheck is not OK (under minimal distance on both X and Y from the PlotSign) then no reward, and sending warning message.

									else

										local err_msg = string.format(
											'%s : You do not earn rewards if you are too close to your Base. Next reward in %s minutes.', tostring(activityRewardsConf.Title), tostring(activityRewardsConf.Timer)
												)
										local notif_base = string.format(
											'%s', tostring(activityRewardsConf.NotifBase)
												)

														g_gameRules.game:SendTextMessage(0, playerId, notif_base)
														g_gameRules.game:SendTextMessage(4, playerId, err_msg)

											LogWarning('ActivityRewards: player[%s]: %s[%s] is too close to his plot sign', tostring(idx), player:GetName(),
												player.player:GetSteam64Id(), player.player:GetSteam64Id())


									end --DistanceCheck end
								end
							end -- BaseCheck end

-- We also give Rewards to players without base - but only if AllowNoBaseRewards is enabled, using the empty PlayerHasBase table

						if not PlayerHasBase[playerId] then

							if activityRewardsConf.AllowNoBaseRewards == 1 then
							--LogWarning('ActivityRewards: AllowNoBaseRewards is enabled')

								local itemCount = activityRewardsConf.RewardItemCount
								local rewardItem = activityRewardsConf.RewardItem

									LogWarning('ActivityRewards: Player[%s]: %s[%s] does not have a base on the server', tostring(idx), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id())
										if activityRewardsConf.RandomRewards == 1 then
											local RndItem, Count = RndTable(activityRewardsConf.SpawnTable)
											local Amount = math.random(Count.min, Count.max)

											mSpawnTools:SpawnAsStacks(playerId, RndItem, Amount)

											g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
										local msg_txt = string.format(
													'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(Amount),
													tostring(RndItem), tostring(activityRewardsConf.Timer)
													)
										g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message

										else
											mSpawnTools:SpawnAsStacks(playerId, rewardItem, itemCount)

										LogWarning(
										'ActivityRewards Gave %s %s to Player : %s[%s]', tostring(itemCount), tostring(rewardItem), player:GetName(),
										player.player:GetSteam64Id(), player.player:GetSteam64Id()
										)

										g_gameRules.game:SendTextMessage(0, playerId, activityRewardsConf.Notification) -- send top message
										local msg_txt = string.format(
													'%s : Recibiste %s %s. Próxima recompensa en %s minutos.', tostring(activityRewardsConf.Title), tostring(itemCount),
													tostring(rewardItem), tostring(activityRewardsConf.Timer)
													)
										g_gameRules.game:SendTextMessage(4, playerId, msg_txt) -- send chat message
									end

							else
								--LogWarning('ActivityRewards: AllowNoBaseRewards is disabled')
							end
						end
					else
					LogWarning('ActivityRewards: WARNING Wrong BaseCheck configuration ! Choose 0 to disable or 1 to enable !')
					end -- Reward end
				end -- AllowSafeZoneReward end
			end
		end
	end --Player loop end
	LogWarning('ActivityRewards: We do not have more players online, proceeding.')
end

-- ──────────────────────────────────────────────────────────────────────────────────── MAIN FUNCTION END ─────────
-------------------------------------------------------------------------------------------------------------------
-- ─── TIMER THREAD ───────────────────────────────────────────────────────────────────────────────────────────────

-- Created and shared by Theros.

---Internally Used to Enable/Disable this thread
---@type boolean
local thread_Run
---Internally used to track thread Status
local thread_Status = 0

local PlayerActivityThread = {
    --- delay between seperate runs
    updateDelay = activityRewardsConf.Timer * 1000,
    --- used to store the timerId for this thread
    TimerId = nil,
}

--- Retriggers the SetTimerForFunction used to setup repeat runs of this thread
---@param updateDelay number delay before starting this thread
function PlayerActivityThread:SchedualUpdateThread(updateDelay)
    --- explicitly set the thread status to 0 (stopped)
    thread_Status = 0
    if thread_Run then -- is thread enabled
        --- Set a timer to call this thread based on current updateRate
        self.TimerId = Script.SetTimerForFunction((updateDelay * 1000), 'ActivityReward_thread', self)
    end
end

--- Starts this Thread, if thread allready started does nothing
function PlayerActivityThread:Start()
    if thread_Status == 0 and (not self.TimerId) then
        --- explicitly set this thread to running
        thread_Run = true
        self:SchedualUpdateThread(2) --- Schedual the thread to run with an initial start timer of 2 seconds
    end
end

--- Stops this Thread, if thread allready stopped does nothing
function PlayerActivityThread:Stop()
    if (thread_Status == 1) and (self.TimerId) then
        --- explicitly set this thread to stopped
        thread_Run = false
        Script.KillTimer(self.TimerId) --- kill any timer assosiated with this thread (ensures its not retriggered)
        self.TimerId = nil --- clear the saved timerId
    end
end

--- default updateRate (5sec)
--- this is the rate that the thread is triggered not the rate of the rewards.
local updateRate = 5
--- Internally used to track lastRun time
local LastRun = 0

--- Our threads main loop
ActivityReward_thread = function(self) -- the self is required for accessing the threads properties.
    --- is this thread enabled?
    if thread_Run then
        --LogWarning('PlayerActivityThread Thread Running') -- enable this if you need a constant running check
        local timeSinceLastRun = (getTime() - LastRun)
        local rewardTimer = (60 * activityRewardsConf.Timer) * 1000
        if (LastRun == 0) or (timeSinceLastRun >= rewardTimer) then --  has enought passed since last reward run (specified by activityRewardsConf.Timer)
            --- Heres your threads main function idealy just make this call a callback or anouther function
            --- that does the hard work.
            ActivityReward(self)
            --- Allways remember to update the LastRun. LastRun and updateRate are used to ensure this thread dosent just rerigger endlessly.
            LastRun = getTime()
        end
        self:SchedualUpdateThread(updateRate)
        thread_Status = 1 -- ensure threads is still running
    end
end

activityRewardsConf.thread = PlayerActivityThread

-- Chat Command ----------------------------------------------------------------------------------------------------------------------

ChatCommands["!reward"] = function(playerId)

	if activityRewardsConf.AllowChatCommand == 1 then

	local rewardTimer = (60 * activityRewardsConf.Timer) * 1000
	local timeSinceLastRun = (getTime() - LastRun)
	local TimeLeft = math.floor(((rewardTimer - timeSinceLastRun)/1000)/60)

	local Reward_CC = string.format(
			'%s : Your next reward will be in %s minutes, and you will recieve %s %s.', tostring(activityRewardsConf.Title), tostring(TimeLeft),
			tostring(activityRewardsConf.RewardItemCount), tostring(activityRewardsConf.RewardItem)
					)
	local RndReward_CC = string.format(
			'%s : Your next reward will be in %s minutes, and the content is unknown.', tostring(activityRewardsConf.Title), tostring(TimeLeft)
					)

		if activityRewardsConf.RandomRewards == 1 then
			g_gameRules.game:SendTextMessage(4, playerId, RndReward_CC);
		else
			g_gameRules.game:SendTextMessage(4, playerId, Reward_CC);
		end
	else
	end
end


-- We got to delay the script in the RegisterCallback so every tools we use have enough time to load.
-- When the script has waited long enough, we can proceed to the Timer Thread.
function DelayTimer()
	LogWarning("ActivityRewards : DelayTimer Ran.")
	-- Fix to secure a required external script file - (mFramework only)
	--[[if not mSpawnTools then
		Script.ReloadScript("Scripts/mFramework/Plugins/mSpawnTools.lua")
		LogWarning('ActivityRewards : mSpawnTools has been reloaded !')
	end]]--
	PlayerActivityThread:Start()
	LogWarning("ActivityRewards: Is Ready, proceeding")
end


local timeout = 5 * 1000
RegisterCallback(_G, 'OnInitAllLoaded', nil, function()
	Log("ActivityRewards : Setting Initial Startup Delay: %ss",tostring((timeout/1000)))
	Script.SetTimerForFunction(timeout, DelayTimer())
end)
